{"version":3,"sources":["webpack:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack:///./src/components/ValidatedInput.tsx","webpack:///./src/pages/index.tsx","webpack:///./src/pages/Index.module.scss"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","ValidatedInput","validate","useState","setValue","setError","isChecking","setIsChecking","useEffect","fn","isChanged","newError","self","this","args","arguments","apply","err","undefined","onChange","useCallback","e","target","style","border","color","indexPageQuery","setTimeout","indexOf","IndexPage","render","props","data","site","siteMetadata","name","tagline","className","styles","React","module","exports"],"mappings":"8NAAA,SAASA,EAAmBC,EAAKC,EAASC,EAAQC,EAAOC,EAAQC,EAAKC,GACpE,IACE,IAAIC,EAAOP,EAAIK,GAAKC,GAChBE,EAAQD,EAAKC,MACjB,MAAOC,GAEP,YADAP,EAAOO,GAILF,EAAKG,KACPT,EAAQO,GAERG,QAAQV,QAAQO,GAAOI,KAAKT,EAAOC,GCJhC,SAASS,EAAT,GAAyE,IAA/CC,EAA+C,EAA/CA,SAA+C,EAClDC,mBAAwB,MAA3CP,EADqE,KAC9DQ,EAD8D,OAElDD,mBAAwB,MAA3CN,EAFqE,KAE9DQ,EAF8D,OAGxCF,oBAAS,GAAtCG,EAHqE,KAGzDC,EAHyD,KAK5EC,qBAAU,WAKN,IDFkCC,ECE9BC,GAAY,EAiBhB,ODnBkCD,ECIjC,YACG,GAAc,OAAVb,EAAJ,CAGAW,GAAc,GACd,IAAMI,QAAiBT,EAASN,GAG3Bc,IACDH,GAAc,GACdF,EAASM,MDbhB,WACL,IAAIC,EAAOC,KACPC,EAAOC,UACX,OAAO,IAAIhB,SAAQ,SAAUV,EAASC,GACpC,IAAIF,EAAMqB,EAAGO,MAAMJ,EAAME,GAEzB,SAASvB,EAAMK,GACbT,EAAmBC,EAAKC,EAASC,EAAQC,EAAOC,EAAQ,OAAQI,GAGlE,SAASJ,EAAOyB,GACd9B,EAAmBC,EAAKC,EAASC,EAAQC,EAAOC,EAAQ,QAASyB,GAGnE1B,OAAM2B,UCIG,WAAQR,GAAY,KAI5B,CAACR,EAAUN,IAId,IAAMuB,EAAWC,uBACb,SAACC,GAAD,OAA4CjB,EAASiB,EAAEC,OAAO1B,SAC9D,IAEJ,OACI,oCACI,2BACI2B,MAAO,CAAEC,QAAUlB,GAAcT,EAAS,iBAAmB,0BAC7DD,MAAOA,GAAS,GAChBuB,SAAUA,IAEbb,EACK,gDAAyBV,EAAzB,QACAC,EACI,yBAAK0B,MAAO,CAAEE,MAAO,SAAW5B,GACtB,OAAVD,EACI,6CACA,M,gBC5Cb8B,EAAiB,aAW9B,SAASxB,EAASN,GAChB,OAAO,IAAIG,SAAQ,SAAAV,GACjBsC,YAAW,WACL/B,GAASA,EAAMgC,QAAQ,QAAU,GACnCvC,EAAQ,MAEVA,EAAQ,iCACP,Q,IAIcwC,E,kGAEZC,OAAP,WAAgB,MAIVjB,KAAKkB,MAAMC,KAAKC,KAAKC,aAFvBC,EAFY,EAEZA,KAFY,EAGZC,QAGF,OACE,gCACE,4BACE,8BACE,0BAAKD,IAGP,uBAAKE,UAAWC,aACd,2IAIA,gBAACrC,EAAD,CAAgBC,SAAUA,Q,GApBCqC,c,qBCrCvCC,EAAOC,QAAU,CAAC,UAAY","file":"component---src-pages-index-tsx-53e0f779dbf1e1d414d8.js","sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import React, { useCallback, useEffect, useState } from 'react';\r\n\r\nexport type ValidateFunction = (value: string) => Promise<string | null>;\r\n\r\nexport interface IValidatedInputProps {\r\n    validate: ValidateFunction;\r\n}\r\n\r\nexport function ValidatedInput({ validate }: IValidatedInputProps): JSX.Element {\r\n    const [value, setValue] = useState<string | null>(null);\r\n    const [error, setError] = useState<string | null>(null);\r\n    const [isChecking, setIsChecking] = useState(false);\r\n\r\n    useEffect(() => {\r\n        // `isChanged` is used to determine if this is this validation has become stale.\r\n        // If the value (or the validate function) is changed, this useEffect instance will be\r\n        // cleaned up, i.e. the returned function below will be called, which sets `isChanged`\r\n        // to true. This lets us know if we should update the UI with this validation result.\r\n        let isChanged = false;\r\n\r\n        (async () => {\r\n            if (value === null) {\r\n                return;\r\n            }\r\n            setIsChecking(true);\r\n            const newError = await validate(value);\r\n\r\n            // After awaiting, we want to make sure the value we validated is not stale.\r\n            if (!isChanged) {\r\n                setIsChecking(false);\r\n                setError(newError);\r\n            }\r\n        })();\r\n\r\n        // The cleanup function, which runs whenever the dependencies are changed.\r\n        return () => { isChanged = true; };\r\n\r\n        // In this case, the dependencies are `[validate, value]` because if either of these change,\r\n        // then the validation result will not be relevant any longer.\r\n    }, [validate, value]);\r\n\r\n    // useCallback will maintain the same instance of the onChange callback, preventing unnecessary re-renders.\r\n    // Since there are no closures here (aside from setValue), we can safely omit any dependencies.\r\n    const onChange = useCallback(\r\n        (e: React.ChangeEvent<HTMLInputElement>) => setValue(e.target.value),\r\n        []);\r\n\r\n    return (\r\n        <>\r\n            <input\r\n                style={{ border: (!isChecking && error) ? '1px solid #f33' : '1px solid currentColor' }}\r\n                value={value || ''}\r\n                onChange={onChange}\r\n            />\r\n            {isChecking\r\n                ? <div>{`checking value \"${value}\"...`}</div>\r\n                : error\r\n                    ? <div style={{ color: '#f33' }}>{error}</div>\r\n                    : value !== null\r\n                        ? <div>You're good.</div>\r\n                        : null\r\n            }\r\n        </>\r\n    );\r\n}\r\n","import { graphql } from 'gatsby';\r\nimport * as React from 'react';\r\nimport { ValidatedInput } from '../components/ValidatedInput';\r\nimport * as styles from './Index.module.scss';\r\n\r\ninterface IndexPageProps {\r\n  data: {\r\n    site: {\r\n      siteMetadata: {\r\n        name: string;\r\n        tagline: string;\r\n      },\r\n    },\r\n  };\r\n}\r\n\r\nexport const indexPageQuery = graphql`\r\n  query IndexPageQuery {\r\n    site {\r\n      siteMetadata {\r\n        name\r\n        tagline\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nfunction validate(value: string): Promise<string | null> {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => {\r\n      if (value && value.indexOf('foo') >= 0) {\r\n        resolve(null);\r\n      }\r\n      resolve('Value does not contain foo.');\r\n    }, 1000);\r\n  });\r\n}\r\n\r\nexport default class IndexPage extends React.Component<IndexPageProps, {}> {\r\n\r\n  public render() {\r\n    const {\r\n      name,\r\n      tagline,\r\n    } = this.props.data.site.siteMetadata;\r\n\r\n    return (\r\n      <>\r\n        <main>\r\n          <header>\r\n            <h1>{name}</h1>\r\n            {/* <p>{tagline}</p> */}\r\n          </header>\r\n          <div className={styles.Container}>\r\n            <p>\r\n              Enter a value. It will validate with a simulated API call,\r\n              and determine if the value contains the text \"foo\".\r\n            </p>\r\n            <ValidatedInput validate={validate} />\r\n          </div>\r\n        </main>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Container\":\"Index-module--Container--xn-23\"};"],"sourceRoot":""}